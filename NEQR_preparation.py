# Generated by Gemini

import numpy as np
import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister
from qiskit import transpile
from qiskit_aer import AerSimulator

def prepare_neqr_circuit(image, n, q, h, w):
    """
    根据输入的二维灰度图像数组制备 NEQR 量子电路
    :param image: 二维 numpy 数组 (大小需为 2^n x 2^n, 像素值为 0-255)
    """

    # 定义量子寄存器：颜色(color)、位置Y(pos_y)、位置X(pos_x)
    c_reg = QuantumRegister(q, name='color')
    y_reg = QuantumRegister(n, name='pos_y')
    x_reg = QuantumRegister(n, name='pos_x')
    qc = QuantumCircuit(c_reg, y_reg, x_reg)

    # --- 步骤 1: 制备位置叠加态 (Step 1) --- [cite: 88, 89]
    # 对所有位置量子比特应用 Hadamard 门，生成均匀叠加态
    qc.h(y_reg)
    qc.h(x_reg)
    qc.barrier()

    # --- 步骤 2: 像素灰度值嵌入 (Step 2) --- [cite: 93, 95]
    # 对每个像素 (Y, X) 进行受控操作
    for y in range(h):
        for x in range(w):
            # 将坐标值转换为二进制字符串，用于控制位设置
            y_bin = format(y, f'0{n}b')
            x_bin = format(x, f'0{n}b')
            
            # 像素的灰度值二进制
            pixel_val = format(image[y, x], f'0{q}b')

            # 处理坐标控制位：如果坐标位为 '0'，需要加 X 门实现“白点控制”
            for i, bit in enumerate(y_bin):
                if bit == '0': qc.x(y_reg[i])
            for i, bit in enumerate(x_bin):
                if bit == '0': qc.x(x_reg[i])

            # 遍历颜色比特：如果该位为 '1'，则应用多控非门 (MCX) [cite: 96, 109]
            # 控制位是所有的位置量子比特 (y_reg 和 x_reg)
            for i, bit in enumerate(pixel_val):
                if bit == '1':
                    # 在 Qiskit 中，控制位为 y_reg + x_reg，目标位为 c_reg 对应的位
                    # 注意：NEQR 论文中 C0 是最高位还是最低位需对齐，此处假设索引 0 为高位
                    qc.mcx(list(y_reg) + list(x_reg), c_reg[i])

            # 还原坐标控制位 (X 门复位)
            for i, bit in enumerate(y_bin):
                if bit == '0': qc.x(y_reg[i])
            for i, bit in enumerate(x_bin):
                if bit == '0': qc.x(x_reg[i])
            
            qc.barrier() # 分隔不同像素的操作，方便观察电路

    return qc

# 示例：制备一个 2x2 的简单图像 [cite: 74, 78]
test_image = np.array([
    [1, 2],
    [3, 4]
])
h, w = test_image.shape
n = int(np.log2(h)) # 位置量子比特数 (假设宽和高相等)
q = 8               # 颜色量子比特数 (灰度 0-255 需要 8 个比特) [cite: 79]

circuit = prepare_neqr_circuit(test_image, n, q, h, w)
# print(circuit.draw()) # 如果电路较小可以打印查看
circuit.draw('mpl', fold=-1)
# plt.show()

def recover_image_from_circuit(qc, n, q):
    """
    运行电路并还原图像
    :param n: 位置比特数 (log2 边长)
    :param q: 颜色比特数 (通常为 8)
    """
    # 1. 为所有量子比特添加测量操作
    qc.measure_all()
    
    # 2. 在模拟器上运行
    backend = AerSimulator()
    t_qc = transpile(qc, backend)
    # 为了确保覆盖所有像素，shots 需要足够大
    result = backend.run(t_qc, shots=10000).result()
    counts = result.get_counts()

    # 3. 初始化空白图像
    side = 2**n
    recovered_img = np.zeros((side, side), dtype=int)

    # 4. 解析测量结果
    for bitstring, _ in counts.items():
        # 顺序为：pos_x(n) + pos_y(n) + color(q)
        color_bits = bitstring[-q:]
        y_bits = bitstring[-(q + n):-q]
        x_bits = bitstring[:-(q + n)]

        # 二进制转十进制
        val = int(color_bits[::-1], 2)
        y = int(y_bits, 2)
        x = int(x_bits, 2)

        recovered_img[y, x] = val

    return recovered_img

print(recover_image_from_circuit(circuit, n, q))